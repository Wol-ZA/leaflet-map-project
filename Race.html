<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Altitude + Corner Violation Demo</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body { height: 100%; margin: 0; }
  #map { height: 100%; }
  #leaderboard {
    position:absolute; top:10px; left:10px;
    background:rgba(0,0,0,0.85); color:#fff;
    padding:16px 18px; border-radius:10px;
    font-family:system-ui; z-index:1000;
    width:420px; max-height:90%; overflow-y:auto;
  }
  #leaderboard h3{margin:0 0 6px;font-size:20px;color:#ffd700;text-align:center;}
  #lb li{display:flex;justify-content:space-between;align-items:center;
         padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.2);}
  #lb li .stats{font-size:14px;white-space:nowrap;color:#ccc;}
  #controls{
    position:absolute; left:460px; top:10px; z-index:1000;
    background:#fff; padding:10px 12px; border-radius:10px;
    box-shadow:0 4px 14px rgba(0,0,0,0.2);
  }
  button{cursor:pointer;border:0;border-radius:8px;padding:6px 10px;
         margin-right:6px;box-shadow:0 2px 6px rgba(0,0,0,0.1);}
</style>
</head>
<body>
<div id="map"></div>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn">Pause</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="leaderboard">
  <h3>üèÅ Accuracy Leaderboard</h3>
  <ol id="lb"></ol>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// === basic map ===
const map = L.map('map').setView([-33.96,22.46],13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  {attribution:'¬© OpenStreetMap'}).addTo(map);

// === helpers ===
function metersToFeet(m){ return m*3.28084; }
function outsideBand(altMeters, minFt=3000, maxFt=4000){
  if(altMeters==null||isNaN(altMeters)) return false;
  const ft = metersToFeet(altMeters);
  return ft<minFt || ft>maxFt;
}

// === global data ===
let route=[], segments=[], corners=[];
const pilotColors = ['#ef4444','#3b82f6','#22c55e','#f59e0b','#a855f7','#14b8a6'];
const pilotNames  = ['Alpha','Bravo','Charlie','Delta','Echo','Foxtrot'];
let pilots=[], timer=null, lastTs=null;

// === fetch route & build ===
fetch('route.geojson').then(r=>r.json()).then(data=>{
  // sort by description if needed
  route = data.features.map(f=>[f.geometry.coordinates[1],f.geometry.coordinates[0]]);
  const line = L.polyline(route,{color:'black',weight:3,dashArray:'6,10'}).addTo(map);
  map.fitBounds(line.getBounds().pad(0.2));

  // build segments for deviation
  for(let i=0;i<route.length-1;i++){
    const a=L.latLng(route[i]), b=L.latLng(route[i+1]);
    segments.push({a,b,len:a.distanceTo(b)});
  }

  // build corners with radius
  const cornerRadius = 500; // meters
  corners = route.map(latlng=>{
    const pt=L.latLng(latlng);
    // draw a visual radius for debugging
    L.circle(pt,{radius:cornerRadius,color:'purple',weight:1,fill:false}).addTo(map);
    return { point:pt, radius:cornerRadius };
  });

  loadRacers();
});

// === racers ===
function loadRacers(){
  let promises=[];
  for(let i=1;i<=6;i++) promises.push(fetch(`Race${i}.geojson`).then(r=>r.json()));
  Promise.all(promises).then(datas=>{
    pilots = datas.map((data,i)=>{
      const coords=data.features.flatMap(f=>f.geometry.coordinates
                        .map(c=>({lat:c[1],lng:c[0],alt:c[2]})));
      const marker=L.circleMarker([coords[0].lat,coords[0].lng],
                    {color:pilotColors[i],radius:7,weight:3,fillOpacity:0.9}).addTo(map);
      const trail=L.polyline([ [coords[0].lat,coords[0].lng] ],
                    {color:pilotColors[i],weight:3}).addTo(map);
      return {
        name:pilotNames[i], color:pilotColors[i],
        coords, index:0, marker, trail,
        totalMeters:0, avgDevSum:0, avgDevCount:0,
        altitude:(coords[0].alt!==99999?coords[0].alt:null),
        finished:false, enabled:true,
        cutViolation:false, altViolation:false,
        cornerCutFlags: corners.map(()=>false),
        cornerAltFlags: corners.map(()=>false)
      };
    });
    buildLeaderboard();
    start();
  });
}

// === tick ===
function advance(p){
  if(p.finished||!p.enabled) return;
  if(p.index>=p.coords.length-1){p.finished=true; return;}
  const cur=p.coords[p.index], nxt=p.coords[p.index+1];
  const valid=[cur.alt,nxt.alt].filter(a=>a!==undefined&&a!==99999);
  if(valid.length>0) p.altitude = valid.reduce((a,b)=>a+b,0)/valid.length;

  const pos=L.latLng((cur.lat+nxt.lat)/2,(cur.lng+nxt.lng)/2);
  p.marker.setLatLng(pos);
  p.trail.addLatLng(pos);
  p.totalMeters += L.latLng(cur).distanceTo(L.latLng(nxt));
  p.index++;

  // === corner cut check ===
  segments.forEach(seg=>{
    const d=pointToSegmentDistance(pos,seg.a,seg.b);
    if(d<20){ p.cutViolation=true; }
  });

  // === altitude radius check ===
  corners.forEach((corner,idx)=>{
    if(!p.cornerAltFlags[idx]){
      const d = pos.distanceTo(corner.point);
      if(d <= corner.radius && outsideBand(p.altitude,3000,4000)){
        p.cornerAltFlags[idx]=true;
        p.altViolation=true;
        p.marker.setStyle({color:'purple'});
      }
    }
  });
}

function tick(ts){
  if(!lastTs) lastTs=ts; lastTs=ts;
  pilots.forEach(p=>advance(p));
  updateLeaderboard();
  timer=requestAnimationFrame(tick);
}

function start(){ if(!timer) timer=requestAnimationFrame(tick); }
function pause(){ if(timer){ cancelAnimationFrame(timer); timer=null; } }
function reset(){
  pause();
  pilots.forEach(p=>{map.removeLayer(p.marker); map.removeLayer(p.trail);});
  pilots=[]; loadRacers();
}

// === small helpers ===
function pointToSegmentDistance(p,a,b){
  const P=L.latLng(p), A=L.latLng(a), B=L.latLng(b);
  const ABx=B.lng-A.lng, ABy=B.lat-A.lat;
  const APx=P.lng-A.lng, APy=P.lat-A.lat;
  const ab2=ABx*ABx+ABy*ABy;
  const t=Math.max(0,Math.min(1,(APx*ABx+APy*ABy)/ab2));
  const closest=L.latLng(A.lat+ABy*t, A.lng+ABx*t);
  return P.distanceTo(closest);
}

// === UI ===
function buildLeaderboard(){
  const lb=document.getElementById('lb'); lb.innerHTML='';
  pilots.forEach((p,i)=>{
    const li=document.createElement('li');
    const stats=document.createElement('span'); stats.className='stats'; stats.id=`stats-${i}`;
    li.innerHTML=`<label><input type="checkbox" checked data-idx="${i}">
      <span style="color:${p.color};font-weight:bold">${p.name}</span></label>`;
    li.appendChild(stats); lb.appendChild(li); p.statsEl=stats;
  });
  lb.querySelectorAll('input').forEach(cb=>{
    cb.onchange=e=>{
      const idx=parseInt(e.target.dataset.idx), pilot=pilots[idx];
      pilot.enabled=e.target.checked;
      if(pilot.enabled){ map.addLayer(pilot.marker); map.addLayer(pilot.trail);}
      else { map.removeLayer(pilot.marker); map.removeLayer(pilot.trail);}
    };
  });
}

function updateLeaderboard(){
  pilots.forEach(p=>{
    const altDisp = p.altitude!=null ? metersToFeet(p.altitude).toFixed(0)+' ft' : '‚Äî';
    p.statsEl.innerHTML =
      `Dist: ${(p.totalMeters/1000).toFixed(2)} km ¬∑ Alt: ${altDisp} `
      + (p.cutViolation?'<span style="color:red">‚ö† CUT</span> ':'')
      + (p.altViolation?'<span style="color:purple">‚ö† ALT</span>':'')
      + (p.finished?' ‚úÖ':'');
  });
}

// === buttons ===
document.getElementById('startBtn').onclick=start;
document.getElementById('pauseBtn').onclick=pause;
document.getElementById('resetBtn').onclick=reset;
</script>
</body>
</html>
