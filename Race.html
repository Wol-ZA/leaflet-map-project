<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>George Accuracy Race ‚Äì Inside Corner Median</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body { height: 100%; margin: 0; }
  #map { height: 100%; }
  #leaderboard { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.85); color: #fff;
    padding: 16px 18px; border-radius: 10px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    z-index: 1000; width: 500px; box-shadow: 0 6px 20px rgba(0,0,0,0.5); max-height: 90%; overflow-y: auto; }
  #leaderboard h3 { margin: 0 0 8px; font-size: 22px; color: #ffd700; text-align: center; }
  #leaderboard small { display: block; font-size: 12px; color: #ccc; text-align: center; margin-bottom: 8px; }
  #lb li { display: flex; justify-content: space-between; align-items: center;
    padding: 8px 10px; font-size: 16px; border-bottom: 1px solid rgba(255,255,255,0.2); }
  #lb li .stats { font-size: 14px; white-space: nowrap; text-align: right; color: #ccc; }
  #controls { position: absolute; left: 370px; top: 10px; z-index: 1000;
    background: rgba(255,255,255,0.95); padding: 10px 12px; border-radius: 10px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.15); font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
  button { cursor: pointer; border: 0; border-radius: 8px; padding: 8px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
</style>
</head>
<body>
<div id="map"></div>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn">Pause</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="leaderboard">
  <h3>üèÅ Accuracy Leaderboard</h3>
  <small>(Lower avg deviation wins)</small>
  <ol id="lb"></ol>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script>
const map = L.map('map').setView([-33.963, 22.461], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let route = [], segments = [], corners = [];

/* ---------- helpers for inside corner math ---------- */
function toXY(lat, lng) {
  const R = 6378137;
  const x = R * lng * Math.PI/180 * Math.cos(lat * Math.PI/180);
  const y = R * lat * Math.PI/180;
  return [x, y];
}
function toLatLng(x, y) {
  const R = 6378137;
  const lat = y / R * 180/Math.PI;
  const lng = x / (R * Math.cos(lat * Math.PI/180)) * 180/Math.PI;
  return [lat, lng];
}
function insideVector(p1, p2, p3) {
  const v1 = [p2[0]-p1[0], p2[1]-p1[1]];
  const v2 = [p3[0]-p2[0], p3[1]-p2[1]];
  const avg = [(v1[0]+v2[0])/2, (v1[1]+v2[1])/2];
  const perp1 = [-avg[1], avg[0]];
  const perp2 = [ avg[1],-avg[0]];
  const cross = v1[0]*v2[1] - v1[1]*v2[0];
  return cross > 0 ? perp1 : perp2;
}
function scaleVector(v, length) {
  const mag = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
  return [v[0]/mag*length, v[1]/mag*length];
}
/* ---------------------------------------------------- */
//Funtion to calculate the altitude band
function metersToFeet(m) { return m * 3.28084; }


  function outsideBand(altMeters, minFt = 1000, maxFt = 2000) {
  if (altMeters == null || isNaN(altMeters)) return false;
  const altFt = metersToFeet(altMeters);
  return altFt < minFt || altFt > maxFt;
}
  
fetch('route.geojson').then(r => r.json()).then(data => {
  // Sort route points
  route = data.features.sort((a, b) => {
    const order = { 'Fp':0,'T1':1,'T2':2,'T3':3,'T4':4,'T5':5,'T6':6,'T7':7,'T8':8,'T9':9,'SP':10 };
    return order[a.properties.description] - order[b.properties.description];
  }).map(f => [f.geometry.coordinates[1], f.geometry.coordinates[0]]);

  const routeLine = L.polyline(route, { color: 'black', weight: 3, dashArray: '6,10' }).addTo(map);
  map.fitBounds(routeLine.getBounds().pad(0.2));

  // Segments for deviation
  segments = [];
  for (let i = 0; i < route.length - 1; i++) {
    const a = L.latLng(route[i]);
    const b = L.latLng(route[i+1]);
    segments.push({ a, b, len: a.distanceTo(b) });
  }

  // === NEW inside-corner medians ===
  const insideLength = 5000;
  const cornerRadius = 5000;// meters ‚Äì make longer/shorter here
  corners = data.features.filter(f => /^T\d+$/i.test(f.properties.description))
    .map(f => {
      const idx = route.findIndex(r => r[0]===f.geometry.coordinates[1] && r[1]===f.geometry.coordinates[0]);
      const prev = idx > 0 ? route[idx-1] : route[idx];
      const next = idx < route.length-1 ? route[idx+1] : route[idx];
      const latlng = L.latLng(route[idx]);
      const p1 = toXY(prev[0], prev[1]);
      const p2 = toXY(route[idx][0], route[idx][1]);
      const p3 = toXY(next[0], next[1]);

      const inside = insideVector(p1,p2,p3);
      const offset = scaleVector(inside, insideLength);
      L.circle(corner.point, { radius: corner.radius, color: 'purple', fillOpacity: 0.05 }).addTo(map);

      const start = toLatLng(p2[0], p2[1]);
      const end   = toLatLng(p2[0]+offset[0], p2[1]+offset[1]);

      // draw line
      const medianLine = L.polyline([start, end], { color:'red', weight:3, dashArray:'4,4' }).addTo(map);

return {
    point: L.latLng(route[idx]),
    medianLayer: medianLine,
    radius: cornerRadius,// ‚úÖ store the Leaflet layer
    idealLength: 0
};
    });

  loadRacers();
});

const pilotColors = ['#ef4444','#3b82f6','#22c55e','#f59e0b','#a855f7','#14b8a6'];
const pilotNames  = ['Alpha','Eric','Etienne','Delta','Echo','Winner'];
let pilots = [], timer = null, lastTs = null;

function pointToSegmentDistance(p,a,b){
  const P=L.latLng(p), A=L.latLng(a), B=L.latLng(b);
  const ABx=B.lng-A.lng, ABy=B.lat-A.lat, APx=P.lng-A.lng, APy=P.lat-A.lat;
  const ab2=ABx*ABx+ABy*ABy, ap_ab=APx*ABx+APy*ABy;
  let t=ap_ab/ab2; t=Math.max(0,Math.min(1,t));
  const closest=L.latLng(A.lat+ABy*t, A.lng+ABx*t);
  return P.distanceTo(closest);
}
function crossedMedian(prev, curr, line) {
  const seg  = turf.lineString([
    [line[0].lng, line[0].lat],
    [line[1].lng, line[1].lat]
  ]);
  const move = turf.lineString([
    [prev.lng, prev.lat],
    [curr.lng, curr.lat]
  ]);
  // Intersects is safer than crosses
  return turf.booleanIntersects(move, seg);
}


  
function loadRacers(){
  let promises=[];
  for(let i=1;i<=6;i++) promises.push(fetch(`Race${i}.geojson`).then(r=>r.json()));
  Promise.all(promises).then(datas=>{
    pilots = datas.map((data,i)=>{
      const coords = data.features.flatMap(f=>f.geometry.coordinates.map(c=>({lat:c[1],lng:c[0],alt:c[2]})));
      const marker = L.circleMarker([coords[0].lat,coords[0].lng],
        {color:pilotColors[i],radius:7,weight:3,fillOpacity:0.9}).addTo(map);
      const trail = L.polyline([[coords[0].lat,coords[0].lng]],
        {color:pilotColors[i],weight:3,opacity:0.9}).addTo(map);

      // create fresh progress arrays PER PILOT (important)
      const cornerProgress = corners.map(()=>({flagged:false}));
      const cornerAltitudeProgress = corners.map(()=>({flagged:false}));
      const cornerAltRadiusProgress = corners.map(()=>({flagged:false}));

      return {
        name: pilotNames[i],
        color: pilotColors[i],
        coords,
        index: 0,
        marker,
        trail,
        totalMeters: 0,
        avgDevSum: 0,
        avgDevCount: 0,
        altitude: (coords[0].alt !== 99999 ? coords[0].alt : null),
        finished: false,
        enabled: true,
        cornerProgress,
        cornerAltitudeProgress,
        cornerAltRadiusProgress, // used for radius-based altitude checks
        cutViolation: false,
        altViolation: false
      };
    });
    buildLeaderboard();
    start();
  });
}

function advanceAlongCoords(p){
  if(p.finished||!p.enabled) return;
  if(p.index>=p.coords.length-1){p.finished=true; return;}
  const current=p.coords[p.index];
  const next=p.coords[p.index+1];
  const validAlts=[current.alt,next.alt].filter(a=>a!==undefined&&a!==99999);
  if(validAlts.length>0) p.altitude=validAlts.reduce((a,b)=>a+b,0)/validAlts.length;

  const prevPos=p.marker.getLatLng();
  const pos=L.latLng((current.lat+next.lat)/2,(current.lng+next.lng)/2);

  p.marker.setLatLng(pos);
  p.trail.addLatLng(pos);
  p.index++;
  p.totalMeters+=L.latLng(current).distanceTo(L.latLng(next));

  // inside corner crossing detection
corners.forEach((corner, idx) => {
  const cp = p.cornerProgress[idx];
  if (!cp.flagged && trailIntersectsMedian(p.trail, corner.medianLayer)) {
    cp.flagged = true;
    p.cutViolation = true;
    p.marker.setStyle({ color:'orange' });
  }
});

// --- NEW altitude band check (independent of cut) ---
corners.forEach((corner, idx) => {
  // ensure this pilot has a per-corner flag array
  const cap = p.cornerAltRadiusProgress[idx];
  if (!cap || cap.flagged) return;

  // current marker position (use pos or marker position)
  const currentPos = p.marker.getLatLng(); // or `pos` if you prefer the interpolated position

  // distance in meters from pilot to corner center
  const dist = currentPos.distanceTo(corner.point);

  // debug logs ‚Äî remove when happy
  // console.log(`${p.name} dist to corner ${idx}: ${dist.toFixed(1)}m alt(m): ${p.altitude}`);

  // if inside radius AND outside allowed altitude band -> flag
  if (dist <= corner.radius && outsideBand(p.altitude, 3000, 4000)) {
    cap.flagged = true;            // per-corner flag
    p.altViolation = true;         // overall pilot alt violation
    console.log(`ALT VIOLATION: ${p.name} at corner ${idx} dist=${dist.toFixed(0)} m alt_ft=${metersToFeet(p.altitude).toFixed(0)}`);
    // visual cue (optional)
    // p.marker.setStyle({ color: 'purple' });
  }
});

  // deviation
  let minDev=Infinity;
  segments.forEach(seg=>{
    const d=pointToSegmentDistance(pos,seg.a,seg.b);
    if(!isNaN(d)&&d<minDev) minDev=d;
  });
  const deviation=minDev!==Infinity?minDev:0;
  p.avgDevSum+=deviation;
  p.avgDevCount++;
  if(p.index>=p.coords.length-1) p.finished=true;
}

function tick(ts){
  if(!lastTs) lastTs=ts; lastTs=ts;

  pilots.forEach(p=>{
    if(!p.enabled || p.finished) return;
    advanceAlongCoords(p);

    // ‚úÖ NEW intersection check using full trail
    corners.forEach((corner, idx) => {
      const cp = p.cornerProgress[idx];
      if (!cp.flagged && trailIntersectsMedian(p.trail, corner.medianLayer)) {
        cp.flagged = true;
        p.cutViolation = true;
        p.marker.setStyle({ color: 'orange' });
      }
    });
  });

  updateLeaderboard();
  timer = requestAnimationFrame(tick);
}

function trailIntersectsMedian(trailLayer, medianLayer) {
  // Bail out if layers not ready
  if (!trailLayer || !medianLayer ||
      !trailLayer.getLatLngs || !medianLayer.getLatLngs) {
    console.warn('‚ö†Ô∏è Missing layer', trailLayer, medianLayer);
    return false;
  }
  const trailCoords = trailLayer.getLatLngs().map(ll => [ll.lng, ll.lat]);
  const medianCoords = medianLayer.getLatLngs().map(ll => [ll.lng, ll.lat]);
   console.log('Trail sample', trailCoords.slice(-2));
  console.log('Median', medianCoords);
  if (trailCoords.length < 2) return false;

  const trailLine = turf.lineString(trailCoords);
  const medianLine = turf.lineString(medianCoords);
  const intersects = turf.booleanIntersects(trailLine, medianLine);
  console.log('Intersection result:', intersects);
  return turf.booleanIntersects(trailLine, medianLine);
}

function start(){if(!timer) timer=requestAnimationFrame(tick);}
function pause(){if(timer){cancelAnimationFrame(timer); timer=null;}}
function reset(){pause(); pilots.forEach(p=>{map.removeLayer(p.marker); map.removeLayer(p.trail);}); loadRacers();}

document.getElementById('startBtn').onclick=start;
document.getElementById('pauseBtn').onclick=pause;
document.getElementById('resetBtn').onclick=reset;

function buildLeaderboard(){
  const lb=document.getElementById('lb'); lb.innerHTML='';
  pilots.forEach((p,i)=>{
    const li=document.createElement('li');
    const statsEl=document.createElement('span'); statsEl.className='stats'; statsEl.id=`stats-${i}`;
    li.innerHTML=`<label><input type="checkbox" checked data-idx="${i}">
      <span style="color:${p.color}; font-weight:bold">${p.name}</span></label>`;
    li.appendChild(statsEl); lb.appendChild(li); p.statsEl=statsEl;
  });
  lb.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
    cb.onchange=e=>{
      const idx=parseInt(e.target.dataset.idx), pilot=pilots[idx];
      pilot.enabled=e.target.checked;
      if(pilot.marker && pilot.trail){
        if(pilot.enabled){ map.addLayer(pilot.marker); map.addLayer(pilot.trail);}
        else { map.removeLayer(pilot.marker); map.removeLayer(pilot.trail);}
      }
    };
  });
}
function updateLeaderboard(){
  pilots.forEach(p=>{
    if(!p.statsEl)return;
    const altDisplay = (p.altitude !== null)
  ? metersToFeet(p.altitude).toFixed(0) + ' ft'
  : '‚Äî';

p.statsEl.innerHTML = `
  Dev: ${p.avgDevCount ? (p.avgDevSum / p.avgDevCount).toFixed(1) + ' m' : '‚Äî'}
  ¬∑ Dist: ${(p.totalMeters/1000).toFixed(2)} km
  ¬∑ Alt: ${altDisplay}
  ${p.cutViolation ? '<span style="color:red">‚ö†Ô∏è CUT</span>' : ''}
  ${p.altViolation ? '<span style="color:purple">‚ö†Ô∏è ALT</span>' : ''}
  ${p.finished ? '‚úÖ' : ''}
`;
  });
}
</script>
</body>
</html>
